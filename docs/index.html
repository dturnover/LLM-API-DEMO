<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>LLM API Demo</title>
  <style>
    body{font-family:system-ui,Arial,sans-serif;max-width:820px;margin:24px auto;padding:0 16px}
    #log{white-space:pre-wrap;border:1px solid #ddd;border-radius:12px;padding:12px;min-height:180px}
    textarea{width:100%;padding:10px} button{padding:8px 14px}
    .row{display:flex;gap:8px;margin-top:10px;align-items:flex-start}.tiny{font-size:12px;color:#666}
  </style>
</head>
<body>
  <h2>LLM API Demo</h2>
  <div id="log"></div>
  <div class="row">
    <textarea id="msg" rows="3" placeholder="Type your message..."></textarea>
    <div>
      <button id="send">Send</button>
      <div class="tiny"><label><input type="checkbox" id="useSSE" checked> stream</label></div>
    </div>
  </div>

<script>
const API="https://llm-api-demo-5qz1.onrender.com";
const log=document.getElementById('log'), msg=document.getElementById('msg'), btn=document.getElementById('send'), useSSE=document.getElementById('useSSE');
function append(t){ log.textContent+=t; log.scrollTop=log.scrollHeight; }
const sleep=ms=>new Promise(r=>setTimeout(r,ms));
async function wake(){ for(let i=0;i<40;i++){ try{const r=await fetch(API+'/',{credentials:'include'}); if(r.ok) return}catch{} await sleep(3000)} }

function streamGET(text){
  const url = API + '/chat_sse_get?q=' + encodeURIComponent(text);
  const es = new EventSource(url, { withCredentials: true });
  es.onopen = () => append(': connected\n');
  es.onmessage = (e) => append(e.data);
  es.addEventListener('sources', (e) => append('\n\n[sources attached]\n'));
  es.addEventListener('done', () => es.close());
  es.onerror = () => {
    append(`\n[stream error] readyState=${es.readyState}\n`);
    es.close();
  };
}

async function postJSON(text){
  const r=await fetch(API+'/chat',{
    method:'POST', credentials:'include',
    headers:{'Content-Type':'application/json'},
    body:JSON.stringify({message:text})
  });
  if(!r.ok){ throw new Error('HTTP '+r.status); }
  return r.json();
}

async function send(){
  const text=msg.value.trim(); if(!text) return;
  msg.value=""; append(`You: ${text}\n\nBot: `);
  await wake();
  try{
    if(useSSE.checked){ streamGET(text); append('\n'); }
    else{ const data=await postJSON(text); append(data.response+"\n\n"); }
  }catch(e){ append(`[network error: ${e.message}]\n\n`); }
}
btn.onclick=send;
msg.addEventListener('keydown',e=>{ if(e.key==='Enter'&&!e.shiftKey){ e.preventDefault(); send(); }});

function streamGET(text){
  const url = API + '/chat_sse_get?q=' + encodeURIComponent(text);

  fetch(url, { credentials: 'include' })
    .then(res => {
      if (!res.ok || !res.body) throw new Error('HTTP '+res.status);
      const reader = res.body.getReader();
      const decoder = new TextDecoder();
      let buffer = '';

      // helper: handle complete SSE events in buffer
      const pump = () => reader.read().then(({ value, done }) => {
        if (done) {
          append('\n'); // end nicely
          return;
        }
        buffer += decoder.decode(value, { stream: true });

        // Split on double newline (SSE event delimiter)
        let idx;
        while ((idx = buffer.indexOf('\n\n')) !== -1) {
          const raw = buffer.slice(0, idx);
          buffer = buffer.slice(idx + 2);

          // Parse minimal SSE (event:, data:)
          const lines = raw.split('\n');
          let eventName = 'message';
          let dataLines = [];
          for (const line of lines) {
            if (line.startsWith(':')) continue;              // comment (e.g., ": connected")
            if (line.startsWith('event:')) eventName = line.slice(6).trim();
            else if (line.startsWith('data:')) dataLines.push(line.slice(5));
          }
          const data = dataLines.join('\n');

          if (eventName === 'message') {
            append(data);                                     // token chunk
          } else if (eventName === 'sources') {
            // optional tail meta
            append('\n\n[sources attached]\n');
          } else if (eventName === 'done') {
            append('\n');                                     // clean line end
          }
        }
        return pump();
      });

      append(': connected\n');
      return pump();
    })
    .catch(err => {
      append(`\n[stream error] ${err.message}\n`);
    });
}


</script>
</body>
</html>
